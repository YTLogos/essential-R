---
title: "R development"
---

The following section covers tools that help and speed up developing R:

- `yeoman`
- `devtools`
- `testthat`
- `roxygen2`
- `covr`
- `lintr`
- `usethis`


# Creating R packages

If you have `yeoman` installed, you can use the `R-bones` generator in order to initialize a complete project. This gives you the following barebone:

```{bash, eval=FALSE}
  yo r-bones
  ls -la newpkg
```
```{bash, include=TRUE, eval=TRUE, echo=FALSE}
  ls -la newpkg
```


# Writing R packages

When creating an R package `devtools` and `covr` cover almost any functionality required. The following functions delineate how my typical workflow looks:

```{r, include=TRUE, eval=FALSE, echo=TRUE}
  devtools::create("newpkg")
  devtools::use_rcpp()  
  devtools::document()  
  devtools::test()
  devtools::check_cran()
  devtools::lint()
  devtools::run_examples()
  covr::package_coverage()
  devtools::install()
```

This basically covers your complete development life cycle. devtools is tremendously useful. If you look for something that helps you write a package, devtools usually has a function for it. For all other things, use usethis.

```{r, include=TRUE, eval=FALSE, echo=TRUE}
  usethis::use_namespace()
  usethis::use_code_of_conduct()
  usethis::use_travis()
  usethis::use_vignette()
  usethis::use_gpl3_license()
```

# Testing code

Right after creating your package, you should write your first test (yes, really). Testing is essential*for writing good software. The same way as programming languages change your way of thinking, unit tests change your way of writing functions. testthat is probably the best way to go here. Tests are usually put in `tests/testthat`. You can use:

```{r, eval=FALSE}
  devtools::use_testthat()
```

to create a test suite automatically. A test would look like this:

```{r, eval=FALSE}
  testthat::test_that("i know my math", {
    testthat::expect_equal(g(), 2)
  })

  testthat::test_that("i know my math", {
      testthat::expect_false("wrong" == "right")
  })
```

Let's test this.

```{r}
  devtools::test("./newpkg")
```

A function ideally does *one task and one task only*. Functions with side effects, multiple operations or exceedingly large method body easily introduce bugs. Keep your functions concise! This also simplifies testing, because it is easier to track down a bug in a shorter function.


# Documenting code

Having written the first unit test, we can create the actual function and its respective documentation using `roxygen2`:

```{r}
  #' @title Adds 1 and 1
  #'
  #' @description This magnificent function computes the sum of 1 and 1.
  #'
  #' @export  
  #'
  #' @return  returns 2
  #'  
  #' @examples
  #'   a <- g()
  #'   print(a)
  g <- function() 1 + 1
```

Then build the documentation:

```{r}
  devtools::document("./newpkg")
```

An excellent help for creating documentation (of S3 and S4) is for instance <a href="https://github.com/variani/pckdev">pckdev</a> or the official <a href="https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html">vignette</a>.


# Checking code

If you want to submit your package to CRAN or Bioconductor certain criteria must be fulfilled. Some of which can be tested by checking or package like this:

```{r,  eval=TRUE, message=TRUE,  include=TRUE, echo=TRUE}
  devtools::check_cran("./newpkg")
```

This does not test for Bioconductor though. For this you have to install <a href="https://bioconductor.org/packages/release/bioc/html/BiocCheck.html"> BioCheck</a> manually and call `R CMD BiocCheck newpkg*.tar` on the command line.


# Static code analysis

lintr checks your code for style, syntax error and possible issues. You can also incorporate lintr in your unit tests and let them fail, if lints are discovered.

```{r, eval=FALSE}
if (requireNamespace("lintr", quietly = TRUE)) {
  test_that("this is lint free", {  
    lintr::expect_lint_free()
  })
}
```

What lintr considers worth reporting can be customized in a .lintr file in your package root directory.

Let's see if our small package is lint free:

```{r, eval=TRUE, message=TRUE,  include=TRUE, echo=TRUE}
  devtools::lint("./newpkg")
```

Whoops!


## Running examples

Examples are extremely helpful both for the user and debugging purposes. When
we documented our function `g` we already have an example how to use the function. We can manually call all examples using:

```{r, eval=TRUE, message=TRUE, include=TRUE, echo=TRUE}
  devtools::run_examples("./newpkg")
```


# Code coverage

covr lets you check how much of your code is used and tested. If you created a package just run:

```{r, eval=TRUE, message=TRUE, include=TRUE, echo=TRUE}
  covr::package_coverage("./newpkg")
```

Having high code coverage usually correlates with a good testing suite. The more functionality is tested, the larger the code coverage. You can customized reports by adding a file called `.codecov.yml` to your project's root:

```{bash}
  cat ./newpkg/.codecov.yml
```


# Profiling and benchmarking

If you think your code runs slowly, you can try to find the bottleneck, for instance, using `profvis` and `microbenchmark`.

```{r, eval=TRUE, message=TRUE, include=TRUE, echo=TRUE, fig.width=4}
  library('profvis')
  library('ggthemes')
  library('gam')
  data(kyphosis)
  profvis::profvis({
    sp <- stats::spline(kyphosis$Age, kyphosis$Number, method="n")
    gm <- gam::gam(Number ~ Age, family=poisson, data=kyphosis)

    df <- data.frame(
      X = c(sp$x, kyphosis$Age),
      Y = c(sp$y, predict(gm, kyphosis)),
      model = c(rep("Spline", length(sp$x)),
                rep("GAM",    length(kyphosis$Age))))

    g <- ggplot2::ggplot(df) +
      ggplot2::geom_point(ggplot2::aes(x=X, y=Y, color=model)) +
      ggthemes::theme_tufte()

    print(g)
  })
```

Often it however suffices to just benchmark two methods against each other.

```{r, eval=TRUE, message=TRUE, include=TRUE, echo=TRUE}
  f <- function(n) {
    sum <- 0
    for (i in seq(n)) sum <- sum + i
  }
  g <- function(.) sum(.)

  microbenchmark::microbenchmark(f(10000), g(10000))
```


# Creating a landing page

At this point you are finished writing your package and you want to provide it to a large user base. A nice landing page often helps gaining popularity. The easiest way to do so is using `pkgdown`.

```{r, eval=FALSE, message=TRUE, include=TRUE, echo=TRUE}
  pkgdown::build_site(pkg= "./newpkg")
```

This creates a web-page like this:

<div align="center">
  <img src="https://rawgit.com/dirmeier/essential-R/master/fig/pkgdown.jpg" alt="oh no" width="500px">
</div>

A good example can be found <a href="https://dirmeier.github.io/netReg/">here</a>.


# Object-oriented programming

R has three different native ways for object-oriented programming and as far as I know one additional library. `S3`, `S4` and `refClasses` (`R5`) come with the standard library, while `R6` can be installed from CRAN. I actually never use R5, because it feels incredibly bulky and slow, so we will not cover it here.


## S3

S3 methods dispatch on the first argument. If you come from other languages, such as `Java`, an S3 method is basically an overloaded function on the first argument. You can define an S3 function like this:

```{r}
  s3 <- function(x, y, ...) UseMethod("s3")

  s3.matrix <- function(x, y, ...) apply(x, 1, sum)
  s3.character <- function(x, y, ...) paste(x, y)

  s3(matrix(1:6, 2))
  s3("hello", "reader")
```

S3 classes are defines like this:

```{r}
  s3.list <- function(x, y, ...)
  {
    l <- list(x=x, y=y)
    base::class(l) <- "my.s3"

    l
  }
  s3(list(x=1), y=2)
```

The main issue here is of course that the user can easily overwrite a class and that method dispatching on one argument usually is not enough. However, often S3 functions are all you need.

## S4

Bioconductor seems to prefer S4 over S3, so if you want to submit your package, you could for instance define interfaces using S4 and the rest using S3 or w/o OO entirely. In that way the user of your package only sees the exported interface (the S4 method) and upon calling would receive an S4 object. The rest of the implementation would be hidden.

```{r, eval=FALSE}
  methods::setClass("normallist",
         representation = list(.el = "list"),
         prototype = methods::prototype(.el = list())
  )

  methods::setGeneric("put", function(obj, x) base::standardGeneric("insert"))

  methods::setMethod(
    "put",
    signature = methods::signature(obj = "normallist", x = "vector"),
    function(obj, x) obj@.el <- as.list(x)
  )

  d <- methods::new("normallist")
  d <- put(d, seq(3))
  d
```
