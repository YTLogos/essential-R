---
title: "Essential R"
output:
  rmdformats::material:
    highlight: default
    self_contained: false
    lib_dir: libs    
    theme: lumen
    number_sections: true
    css: ["default", "theme.css"]        
    nature:
      highlightStyle: default
      highlightLines: true


---

```{r knitr_init, echo=FALSE, cache=FALSE, message=FALSE}
  library(knitr)
  library(rmdformats)  
  library(magrittr)
  library(devtools)
  devtools::install("./newpkg")
  options(htmltools.dir.version = FALSE)
  options(max.print="75")
  opts_chunk$set(#cache=TRUE,
                 prompt=FALSE,
                 tidy=TRUE,
                 comment=NA,
                 message=FALSE,
                 warning=FALSE)
```

# Intro

<div>
  <i>Programs must be written for people to read, and only incidentally for machines to execute.</i>
</div>
<div class="quote">
-- Harold Abelson
</div>
<div style="margin-top: 2%">
  <i>The lyf so short, the craft so long to lerne.</i>
</div>
<div class="quote" style="margin-bottom: 5%">
-- Geoffrey Chaucer
</div>


These slides are a rough guideline of how to write `R` code using common
software, such as `devtools`, `testthat`, `lintr`, `covr`, `data.table`, `Rcpp` and its derivates, and other frequently used tools to program in `R`. We don't claim at any point that the material treated here covers all of R, but rather serve as a the author's list of essential `R` tools he frequently uses.

These slides are no introduction on how to program functionally, procedurally or in an object-oriented way, how to write code in general, or how to speed it up. The interested reader is referred to:

- Robert Martin: Clean Code,
- Andrew Hunt: The Pragmatic Programmer,
- Gang of Four: Design Patterns,
- Hadley Wickham: R packages,
- Hadley Wickham: Advanced R,
- Dirk Eddelbuettel: Seamless R and C++ Integration with Rcpp,
- Thomas Cormen: Introduction to Algorithms,
- Dan Gusfield: Algorithms on Strings, Trees and Sequences,
- Donald Knuth: The Art of Computer Programming,
- A <a href="http://norvig.com/21-days.html">comment</a> by Peter Norvig.


# R development

The following section covers tools that help and speed up developing R:

- `yeoman`
- `devtools`
- `testthat`
- `roxygen2`
- `covr`
- `lintr`
- `usethis`

## Creating R packages

If you have `yeoman` installed, you can use the `R-bones` generator in order to initialize a complete project. This gives you the following barebone:

```{bash, eval=FALSE}
  yo r-bones
  ls -la newpkg
```
```{bash, include=TRUE, eval=TRUE, echo=FALSE}
  ls -la newpkg
```


## Writing R packages

When creating an R package `devtools` and `covr` covers almost any functionality required. The following functions delineate how my typical workflow looks:

```{r, include=TRUE, eval=FALSE, echo=TRUE}
  devtools::create("newpkg")
  devtools::test()
  devtools::document()
  devtools::check_cran()
  devtools::lint()
  devtools::run_examples()
  covr::package_coverage()
  devtools::install()
  devtools::use_rcpp()  
```

This basically covers your complete development life cycle (except code coverage). `devtools` is **tremendously** useful. If you look for sth that helps you write packages, `devtools` has a function for it. For all other things, use `usethis`.

```{r, include=TRUE, eval=FALSE, echo=TRUE}
  usethis::use_namespace()
  usethis::use_code_of_conduct()
  usethis::use_travis()
  usethis::use_vignette()
  usethis::use_gpl3_license()
```


## Testing code

Right after creating your package, you should write your first test (yes, really). Testing is **essential** for writing good software. The same way as programming languages change your way of thinking, do unit tests change your way of writing functions. `testthat` is probably the best way to go here. Tests are usually put in `tests/testthat`.
You can use:

```{r, eval=FALSE}
  devtools::use_testthat()
```

to create a test suite automatically. A test would look like this:

```{r, eval=FALSE}
  testthat::test_that("i know my math", {
    testthat::expect_equal(g(), 2)
  })

  testthat::test_that("i know my math", {
      testthat::expect_false("wrong" == "right")
  })
```

Let's test this.

```{r}
  devtools::test("./newpkg")
```

A function ideally does *one task and one task only*. Functions with side effects, multiple operations or exceedingly large method body easily introduce bugs. Keep your functions concise! This also simplifies testing, because it is easier to track down a bug in a shorter function.


## Documenting code

Having written the first unit test, we can create the actual function for it **and** its documentation using `roxygen2`:

```{r}
  #' @title Adds 1 and 1
  #'
  #' @description This magnificent function computes the sum of 1 and 1.
  #'
  #' @export  
  #'
  #' @return  returns 2
  #'  
  #' @examples
  #'   a <- g()
  #'   print(a)
  g <- function() 1 + 1
```

Then build the documentation:

```{r}
  devtools::document("./newpkg")
```

An excellent help for creating documentation (of S3 and S4) is for instance <a href="https://github.com/variani/pckdev">pckdev</a> or the official <a href="https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html">vignette</a>.


## Checking code

If you want to submit your package to `CRAN` or `Bioconductor` certain criteria must be fulfilled. Some of which can be tested by checking or package like this:

```{r,  eval=TRUE, message=TRUE,  include=TRUE, echo=TRUE}
  devtools::check_cran("./newpkg")
```

This does not test for Bioconductor though. For this you have to install <a href="https://bioconductor.org/packages/release/bioc/html/BiocCheck.html"> BioCheck</a> manually and call `R CMD BiocCheck newpkg*.tar` on the command line.


## Static code analysis

`lintr` checks your code for style, syntax error and possible issues. You can also incorporate `lintr` in your unit tests and let them fail, if lints are discovered.

```{r, eval=FALSE}
if (requireNamespace("lintr", quietly = TRUE)) {
  test_that("this is lint free", {  
    lintr::expect_lint_free()
  })
}
```

What `lintr` considers worth reporting can be customized in a `.lintr` file in your package root directory.

Let's see if our small package is lint free:

```{r, eval=TRUE, message=TRUE,  include=TRUE, echo=TRUE}
  devtools::lint("./newpkg")
```

Whoops!


## Running examples

Examples are extremely helpful both for the user and debugging purposes. When
we documented our function `g` we already have an example how to use the function. We can manually call all examples using:

```{r, eval=TRUE, message=TRUE, include=TRUE, echo=TRUE}
  devtools::run_examples("./newpkg")
```


## Code coverage

`covr` lets you check how much of your code is used and tested. If you created a package just run:

```{r, eval=TRUE, message=TRUE, include=TRUE, echo=TRUE}
  covr::package_coverage("./newpkg")
```

Having high code coverage usually correlates with a good testing suite. The more functionality is tested, the larger the code coverage.

## Profiling and benchmarking

If you think your code runs slowly, you can try to find the bottleneck, for instance, using `profvis` and `microbenchmark`.

```{r, eval=TRUE, message=TRUE, include=TRUE, echo=TRUE}
  library('ggplot2')
  profvis::profvis({
    g <- ggplot(diamonds, aes(carat, price)) + geom_point(size=1, alpha=.2)
    invisible(print(g))
  })
```

Often it however suffices to just benchmark two methods against each other.

```{r, eval=TRUE, message=TRUE, include=TRUE, echo=TRUE}
  f <- function(n) {
    sum <- 0
    for (i in seq(n)) sum <- sum + i
  }
  g <- function(.) sum(.)

  microbenchmark::microbenchmark(f(10000), g(10000))
```


## Creating a landing page

At this point you are finished writing your package and you want to provide it to a large user base. A nice landing page often helps gaining popularity. The easiest way to do so is using `pkgdown`.

```{r, eval=FALSE, message=TRUE, include=TRUE, echo=TRUE}
  pkgdown::build_site(pkg= "./newpkg")
```

This creates a web-page like this:

<div align="center">
  <img src="https://rawgit.com/dirmeier/essential-R/master/fig/pkgdown.jpg" alt="oh no" width="750px">
</div>

A good example can be found <a href="https://dirmeier.github.io/netReg/">here</a>.


# Good practices

Continuous integration, version control and containerization are three of the many tools of a developer. Here, we quickly introduce how the three can be used for `R`.

## Continuous integration

Setting up continuous Integration: `Travis CI` and `AppVeyor`

To be honest, doing all these steps is tedious and annoying. For that reason we set up `Travis CI` to take care of running our tests, static analysis and code coverage. Travis works for Mac and Unix.

```{bash}
  cat ./newpkg/.travis.yml
```

Check out Travis' <a href="https://docs.travis-ci.com/">docs</a> for more info. What we are basically telling Travis to do is to check our package `--as-cran`, run the unit tests, do the code coverage and finally do a static code analysis.

In order to do the same for Windows machines, we also use AppVeyor.

```{bash}
  cat ./newpkg/appveyor.yml
```

Here, we only run some tests and checks, since we already got the code analysis and coverage.

Code coverage of our project yielded us the following results:

<div align="center">
  <img src="https://codecov.io/gh/dirmeier/essential-R/branch/master/graphs/sunburst.svg" alt="no img">
</div>
<div style="text-align: center">
  Code coverage
</div>

If we check the travis log, we see it has succeeded, because all tests ran through. However, we have some lints we should fix.

<pre><code>$ tar -C .. -xf $PKG_TARBALL
after_script.2
2.22s$ Rscript -e 'covr::codecov()'
$message
[1] "Coverage reports upload successfully"
$id
[1] "552fd0db-187b-434e-b37b-a0e4fcba7636"
$meta
$meta$status
[1] 200
$queued
[1] TRUE
$url
[1] "https://codecov.io/github/dirmeier/essential-R/commit/f24d277296f78512524f26f3ca3b31d202e122a1"
$uploaded
[1] TRUE
after_script.3
1.23s$ Rscript -e 'lintr::lint_package()'
R/bad_bad_file.R:3:1: style: lines should not be more than 80 characters.
                                                                              myRet = a+b
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
R/bad_bad_file.R:3:79: style: Variable and function names should be all lowercase.
                                                                              myRet = a+b
                                                                              ^~~~~
R/bad_bad_file.R:3:85: style: Use <-, not =, for assignment.
                                                                              myRet = a+b
                                                                                    ^
Warning message:
In readLines(filename) :
  incomplete final line found on '/home/travis/build/dirmeier/essential-R/newpkg/R/emptypRoject-package.R'
Done. Your build exited with 0.</code></pre>


Fixing style related issues is essential since we want other people to be able to read our code easily. Good code also increases the number of users, because the package is more trusted than a *spaghetti code* package.

<div>
  <i>Beauty is more important in computing than anywhere else in technology because software is so complicated. Beauty is the ultimate defense against complexity.</i>
</div>
<div class="quote" style="margin-bottom: 5%">
-- David Gelernter
</div>


## Version control

Aside from he fact that version control is great, putting your project on `GitHub` has the most prominent advantage that you can add badges to your `README.md` to show others about the state of your package, for instance repository, CI or code coverage status.

<div align="center">
  <img src="https://rawgit.com/dirmeier/essential-R/master/fig/readme_me.jpg" alt="oh no" width="750px">
</div>

There's a wide variety of badges to describe your project.
<div align="center">
| Description  | Badge |
| ------------- | ------------- |
| Is the project passing on windows?  | <img src="https://ci.appveyor.com/api/projects/status/github/dirmeier/netReg?branch=master&svg=true">  |
| How long is it on Bioconductor?  | ![](https://bioconductor.org/shields/years-in-bioc/netReg.svg)  |
| Is it installable using conda?  | ![](https://anaconda.org/bioconda/netreg/badges/installer/conda.svg)  |
| What is its version on CRAN?  | ![](http://www.r-pkg.org/badges/version/datastructures?color=brightgreen)  |
| How often has it been downloaded?  | ![](http://cranlogs.r-pkg.org/badges/grand-total/datastructures?color=brightgreen)  |
</div>


## Docker


# R libraries

Much of `R`'s popularity is due to its fantastic ecosystem. `R` users benefit heavily from CRAN and Bioconductor packages created by its community.

For data analysis or statistics `R` is a good choice for various reasons:

- high-level,
- easy to install packages,
- can be extended to `C++` without needing knowledge of linking or `C++` build-systems,
- probably the best plotting facility with `ggplot`, `cowplot`, `hrbrthemes` or `ggsci`,
- Bioconductor, machine learning and statistics libraries,
- small standard library.

There are a few things, however, `R` is not so great at:

- in general slow,
- not really suited for large projects,
- poor object orientation,
- inconsistent function names,
- superior IDEs for Java, Python, ...,
- very limited threading capabilities.

## Extending to C++ using `Rcpp`

Using `Rcpp` (and `RcppEigen`, `RcppArmadillo`, `Boost`) you can easily your extend your code to C++. It not only nicely wraps the standard C API, but also let's you use standard matrix libraries such as Eigen and Armadillo or Boost :heart_eyes:.

If you have a project that's not a package you can for instance create a function like this:

```{r}  
  Rcpp::cppFunction('double sum(std::vector<double>& vec) {
      double sum = .0;
      for (std::vector<double>::size_type i = 0; i < vec.size(); ++i)
          sum += vec[i];
      return sum;
  }')


  sum(as.numeric(seq(10)))
```

Let's see an `Eigen` example with sourceCpp:

```{bash}
  cat ./square.cpp
```

```{r}  
  library('RcppEigen')
  Rcpp::sourceCpp("./square.cpp")
  square(matrix(rnorm(10), 2))
```

Even for small matrices, the speed up is already substantial.

```{r}  
  m <- matrix(rnorm(100 * 100), 100)
  microbenchmark::microbenchmark(
    square(m),
    t(m) %*% m
  )
```

### Rcpp in a package

Usually, you would want to put your source code into a `cpp` file in the `src` folder. Then you can call C++ from an R function, for instance as described below.

1) Define a C++ source file and put it in `src`, like this:

<pre><code>#include <Rcpp.h>

// [[Rcpp::export]]
Rcpp::List dostuff()
{
  // some computations

  return Rcpp::List::create(
    Rcpp::Named("a") = ...
  );
}</code></pre>


2) Add this to your `DESCRIPTION`:

<pre><code>Imports: Rcpp
LinkingTo: Rcpp</code></pre>

3) Add a comment `#' @useDynLib newpkg, .registration = TRUE` to the documentation of any function, better yet to the package doc.

4) Call `devtools::document()`

5) Call `Rcpp::compileAttributes("./newpkg")`


This should let you access the C++ function from your package. For more details check out the main <a href="http://www.rcpp.org/">documentation</a> or some of my packages, like <a href="https://github.com/dirmeier/netReg">netReg</a> or <a href="https://github.com/dirmeier/datastructures">datastructures</a>. The latter also has an example how to use modules and Boost.


## Functional programming with `purr`

TODO

## Plotting

ggplot, hrbrthemes, colorblindr, colorspace, ggthemr, ggsci, magick, imagr, tweenr, plotly, gggraph, ggnetwork, viridis, viridisLite, scales

### Colors


## data.table

## mlR

## S3, S4, R6

## Shiny

## Pryr

## datastructures

## Other

dplyr, tidyr, ORKernel, minqq, nloptr,
