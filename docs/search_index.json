[
["index.html", "Essential R Abstract", " Essential R Simon Dirmeier 2018-10-05 Abstract The lyf so short, the craft so long to lerne. – Geoffrey Chaucer This book serves as a collection of tools for package development, good practices for programming, and my most frequently used packages. The material treated here certainly does not cover all of R, but rather serves as my personal list of essential things related to programming in R that I found useful to know. The document is partly opinionated and subjective, so feel free to open up an issue if you feel some parts should be clarified or reformulated. The book is no introduction on how to program functionally, procedurally or in an object-oriented way, how to write code in general, or how to speed it up. The interested reader is referred to: Robert Martin: Clean Code, Andrew Hunt: The Pragmatic Programmer, Gang of Four: Design Patterns, Colin Gillespie: Efficient R programming, Patrick Burns: The R Inferno, Hadley Wickham: R packages, Hadley Wickham: Advanced R, Dirk Eddelbuettel: Seamless R and C++ Integration with Rcpp, Thomas Cormen: Introduction to Algorithms, Dan Gusfield: Algorithms on Strings, Trees and Sequences, Donald Knuth: The Art of Computer Programming, a comment by Peter Norvig, … "],
["r-package-development.html", "1 R package development 1.1 Creating R packages 1.2 Writing R packages 1.3 Testing code 1.4 Documenting code 1.5 Checking code 1.6 Static code analysis 1.7 Code coverage 1.8 Profiling and benchmarking 1.9 Creating a landing page", " 1 R package development The following section covers tools that help and speed up developing R 1.1 Creating R packages A minimum R-package stack at least consists of the following packages of tools: yeoman devtools testthat roxygen2 covr lintr usethis If you have yeoman installed, you can use the R-bones generator in order to initialize a complete project. This gives you the following barebone: yo r-bones ls -la pkg total 1624 drwxr-xr-x 26 simondi 1029 832 Jan 26 2018 . drwxr-xr-x 31 simondi 1029 992 Oct 5 22:43 .. -rw-r--r-- 1 simondi 1029 220 Jan 22 2018 .Rbuildignore drwxr-xr-x 4 simondi 1029 128 Jan 23 2018 .Rproj.user -rw-r--r-- 1 simondi 1029 410 Jan 22 2018 .codecov.yml -rw-r--r-- 1 simondi 1029 51 Jan 22 2018 .gitattributes -rw-r--r-- 1 simondi 1029 421 Jan 22 2018 .gitignore -rw-r--r-- 1 simondi 1029 556 Jan 22 2018 .lintr -rw-r--r-- 1 simondi 1029 829 Jan 23 2018 .travis.yml -rw-r--r-- 1 simondi 1029 176 Jan 22 2018 .yo-rc.json -rw-r--r-- 1 simondi 1029 548 Jan 23 2018 DESCRIPTION -rw-r--r-- 1 simondi 1029 35141 Jan 22 2018 LICENSE -rw-r--r-- 1 simondi 1029 56 Jan 23 2018 NAMESPACE drwxr-xr-x 4 simondi 1029 128 Jan 23 2018 R -rw-r--r-- 1 simondi 1029 556 Jan 24 2018 README.md -rw-r--r-- 1 simondi 1029 93 Jan 22 2018 TODO.md -rw-r--r-- 1 simondi 1029 136 Jan 22 2018 VERSIONS.md -rw-r--r-- 1 simondi 1029 885 Jan 26 2018 appveyor.yml drwxr-xr-x 11 simondi 1029 352 Jan 24 2018 docs drwxr-xr-x 3 simondi 1029 96 Jan 22 2018 inst drwxr-xr-x 3 simondi 1029 96 Jan 23 2018 man -rw-r--r-- 1 simondi 1029 354 Jan 24 2018 newpkg.Rproj -rw-r--r-- 1 simondi 1029 736082 Jan 23 2018 newpkg.html drwxr-xr-x 2 simondi 1029 64 Jan 23 2018 src drwxr-xr-x 4 simondi 1029 128 Jan 22 2018 tests drwxr-xr-x 3 simondi 1029 96 Jan 22 2018 vignettes 1.2 Writing R packages When creating an R package devtools and covr cover almost any functionality required. The following functions delineate how my typical workflow looks: devtools::create(&quot;pkg&quot;) devtools::use_rcpp() devtools::document() devtools::test() devtools::check_cran() devtools::lint() devtools::run_examples() covr::package_coverage() devtools::install() This basically covers your complete development life cycle. devtools is tremendously useful. If you look for something that helps you write a package, devtools usually has a function for it. For all other things, use usethis. usethis::use_namespace() usethis::use_code_of_conduct() usethis::use_travis() usethis::use_vignette() usethis::use_gpl3_license() 1.3 Testing code Right after creating your package, you should write your first test (yes, really). Testing is essential*for writing good software. The same way as programming languages change your way of thinking, unit tests change your way of writing functions. testthat is probably the best way to go here. Tests are usually put in tests/testthat. You can use: devtools::use_testthat() to create a test suite automatically. A test would look like this: testthat::test_that(&quot;i know my math&quot;, { testthat::expect_equal(g(), 2) }) testthat::test_that(&quot;i know my math&quot;, { testthat::expect_false(&quot;wrong&quot; == &quot;right&quot;) }) Let’s test this. devtools::test(&quot;./pkg&quot;) ✔ | OK F W S | Context ⠏ | 0 | hello ⠋ | 1 | hello ⠙ | 2 | hello ✔ | 2 | hello ══ Results ════════════════════════════════════════════════════════════════ Duration: 0.1 s OK: 2 Failed: 0 Warnings: 0 Skipped: 0 A function ideally does one task and one task only. Functions with side effects, multiple operations or exceedingly large method body easily introduce bugs. Keep your functions concise! This also simplifies testing, because it is easier to track down a bug in a shorter function. 1.4 Documenting code Having written the first unit test, we can create the actual function and its respective documentation using roxygen2: #&#39; @title Adds 1 and 1 #&#39; #&#39; @description This magnificent function computes the sum of 1 and 1. #&#39; #&#39; @export #&#39; #&#39; @return returns 2 #&#39; #&#39; @examples #&#39; a &lt;- g() #&#39; print(a) g &lt;- function() 1 + 1 Then build the documentation: devtools::document(&quot;./pkg&quot;) An excellent help for creating documentation (of S3 and S4) is for instance pckdev or the official vignette. 1.5 Checking code If you want to submit your package to CRAN or Bioconductor certain criteria must be fulfilled. Some of which can be tested by checking or package like this: devtools::check_cran(&quot;./pkg&quot;) Checking 1 CRAN packages ================================================= Results saved in /var/folders/cx/v45t2v2n6b548_vfn76vnzlw0050sr/T//Rtmpb96f0q/check_cran176cf2279a097 Package library: /private/var/folders/cx/v45t2v2n6b548_vfn76vnzlw0050sr/T/Rtmpb96f0q/R-lib, /Library/Frameworks/R.framework/Versions/3.5/Resources/library Installing dependencies -------------------------------------------------- Installing 1 packages: ./pkg Skipping 1 packages without source:./pkg Checking packages -------------------------------------------------------- Checking 0 packages: Package library: /private/var/folders/cx/v45t2v2n6b548_vfn76vnzlw0050sr/T/Rtmpb96f0q/R-lib, /Library/Frameworks/R.framework/Versions/3.5/Resources/library NULL This does not test for Bioconductor though. For this you have to install BioCheck manually and call R CMD BiocCheck newpkg*.tar on the command line. 1.6 Static code analysis lintr checks your code for style, syntax error and possible issues. You can also incorporate lintr in your unit tests and let them fail, if lints are discovered. if (requireNamespace(&quot;lintr&quot;, quietly = TRUE)) { test_that(&quot;this is lint free&quot;, { lintr::expect_lint_free() }) } What lintr considers worth reporting can be customized in a .lintr file in your package root directory. Let’s see if our small package is lint free: devtools::lint(&quot;./pkg&quot;) Linting newpkg R/bad_bad_file.R:3:1: style: lines should not be more than 80 characters. myRet = a+b ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ R/bad_bad_file.R:3:79: style: Variable and function names should be all lowercase. myRet = a+b ^~~~~ R/bad_bad_file.R:3:85: style: Use &lt;-, not =, for assignment. myRet = a+b ^ Whoops! 1.6.1 Running examples Examples are extremely helpful both for the user and debugging purposes. When we documented our function g we already have an example how to use the function. We can manually call all examples using: devtools::run_examples(&quot;./pkg&quot;) Updating newpkg documentation Loading newpkg Running 1 example files in newpkg ---------------------------------------- Loading newpkg Running examples in g.Rd ------------------------------------------------- &gt; &gt; a &lt;- g() &gt; print(a) [1] 2 Loading newpkg 1.7 Code coverage covr lets you check how much of your code is used and tested. If you created a package just run: covr::package_coverage(&quot;./pkg&quot;) newpkg Coverage: 50.00% R/bad_bad_file.R: 0.00% R/newpkg.R: 100.00% Having high code coverage usually correlates with a good testing suite. The more functionality is tested, the larger the code coverage. You can customized reports by adding a file called .codecov.yml to your project’s root: cat ./pkg/.codecov.yml comment: behavior: default layout: header, diff require_changes: false coverage: precision: 2 range: - 70.0 - 100.0 round: down status: changes: false patch: true project: true parsers: gcov: branch_detection: conditional: true loop: true macro: false method: false javascript: enable_partials: false ignore: - &quot;inst/include/&quot; - &quot;inst/&quot; 1.8 Profiling and benchmarking If you think your code runs slowly, you can try to find the bottleneck, for instance, using profvis and microbenchmark. library(&quot;profvis&quot;) library(&quot;ggthemes&quot;) library(&quot;gam&quot;) data(kyphosis) profvis::profvis({ sp &lt;- stats::spline(kyphosis$Age, kyphosis$Number, method = &quot;n&quot;) gm &lt;- gam::gam(Number ~ Age, family = poisson, data = kyphosis) df &lt;- data.frame(X = c(sp$x, kyphosis$Age), Y = c(sp$y, predict(gm, kyphosis)), model = c(rep(&quot;Spline&quot;, length(sp$x)), rep(&quot;GAM&quot;, length(kyphosis$Age)))) g &lt;- ggplot2::ggplot(df) + ggplot2::geom_point(ggplot2::aes(x = X, y = Y, color = model)) + ggthemes::theme_tufte() print(g) }) Often it however suffices to just benchmark two methods against each other. f &lt;- function(n) { sum &lt;- 0 for (i in seq(n)) sum &lt;- sum + i } g &lt;- function(.) sum(.) microbenchmark::microbenchmark(f(10000), g(10000)) Unit: nanoseconds expr min lq mean median uq max neval cld f(10000) 367060 383177.5 667397.48 436338.5 657218.5 8424805 100 b g(10000) 425 808.5 37110.75 1739.0 4487.5 3326589 100 a 1.9 Creating a landing page At this point you are finished writing your package and you want to provide it to a large user base. A nice landing page often helps gaining popularity. The easiest way to do so is using pkgdown. pkgdown::build_site(pkg = &quot;./pkg&quot;) This creates a web-page like this: A good example can be found here. "],
["programming-paradigma-in-r.html", "2 Programming paradigma in R 2.1 Functional programming 2.2 Object-oriented programming", " 2 Programming paradigma in R 2.1 Functional programming TODO 2.2 Object-oriented programming R has three different native ways for object-oriented programming and as far as I know one additional library. S3, S4 and refClasses (R5) come with the standard library, while R6 can be installed from CRAN. I actually never use R5, because it feels incredibly bulky and slow, so we will not cover it here. 2.2.1 S3 S3 methods dispatch on the first argument. If you come from other languages, such as Java, an S3 method is basically an overloaded function on the first argument. You can define an S3 function like this: s3 &lt;- function(x, y, ...) UseMethod(&quot;s3&quot;) s3.matrix &lt;- function(x, y, ...) apply(x, 1, sum) s3.character &lt;- function(x, y, ...) paste(x, y) s3(matrix(1:6, 2)) [1] 9 12 s3(&quot;hello&quot;, &quot;reader&quot;) [1] &quot;hello reader&quot; S3 classes are defines like this: s3.list &lt;- function(x, y, ...) { l &lt;- list(x = x, y = y) base::class(l) &lt;- &quot;my.s3&quot; l } s3(list(x = 1), y = 2) $x $x$x [1] 1 $y [1] 2 attr(,&quot;class&quot;) [1] &quot;my.s3&quot; The main issue here is of course that the user can easily overwrite a class and that method dispatching on one argument usually is not enough. However, often S3 functions are all you need. 2.2.2 S4 Bioconductor seems to prefer S4 over S3, so if you want to submit your package, you could for instance define interfaces using S4 and the rest using S3 or w/o OO entirely. In that way the user of your package only sees the exported interface (the S4 method) and upon calling would receive an S4 object. The rest of the implementation would be hidden. methods::setClass(&quot;normallist&quot;, representation = list(.el = &quot;list&quot;), prototype = methods::prototype(.el = list())) methods::setGeneric(&quot;put&quot;, function(obj, x) base::standardGeneric(&quot;insert&quot;)) methods::setMethod(&quot;put&quot;, signature = methods::signature(obj = &quot;normallist&quot;, x = &quot;vector&quot;), function(obj, x) obj@.el &lt;- as.list(x)) d &lt;- methods::new(&quot;normallist&quot;) d &lt;- put(d, seq(3)) 2.2.3 R5 2.2.4 R6 "],
["good-practices.html", "3 Good practices 3.1 Continuous integration 3.2 Version control 3.3 Docker 3.4 Code style", " 3 Good practices Continuous integration, version control and containerization are three of the many tools of a developer. Here, I quickly introduce how the three can be used for R. 3.1 Continuous integration To be honest, doing all the steps from the section above is tedious and annoying. For that reason I set up Travis CI to take care of running our tests, static analysis and code coverage in the project. Travis works for Mac and Unix. cat ./pkg/.travis.yml language: r sudo: required dist: trusty cache: packages matrix: include: - compiler: gcc addons: apt: sources: - ubuntu-toolchain-r-test packages: - g++-5 env: COMPILER=g++-5 - compiler: clang addons: apt: sources: - ubuntu-toolchain-r-test - llvm-toolchain-precise-3.7 packages: - clang-3.7 env: COMPILER=clang++-3.7 env: global: - R_BUILD_ARGS=&quot;--no-build-vignettes --no-manual&quot; - R_CHECK_ARGS=&quot;--no-build-vignettes --no-manual --as-cran&quot; - LINTR_COMMENT_BOT=false before_install: - cd newpkg r_packages: - covr - testthat - lintr after_script: - tar -C .. -xf $PKG_TARBALL - Rscript -e &#39;covr::codecov()&#39; - Rscript -e &#39;lintr::lint_package()&#39; Check out Travis’ docs for more info. What we are basically telling Travis to do is to check our package --as-cran, run the unit tests, do the code coverage and finally do a static code analysis. In order to do the same for Windows machines, we also use AppVeyor. cat ./pkg/appveyor.yml # DO NOT CHANGE the &quot;init&quot; and &quot;install&quot; sections below # Download script file from GitHub init: ps: | $ErrorActionPreference = &quot;Stop&quot; Invoke-WebRequest http://raw.github.com/krlmlr/r-appveyor/master/scripts/appveyor-tool.ps1 -OutFile &quot;..\\appveyor-tool.ps1&quot; Import-Module &#39;..\\appveyor-tool.ps1&#39; install: ps: Bootstrap # Adapt as necessary starting from here before_build: ps: cd newpkg build_script: - ps: cd newpkg - travis-tool.sh install_deps test_script: - travis-tool.sh run_tests on_failure: - 7z a failure.zip *.Rcheck\\* - appveyor PushArtifact failure.zip artifacts: - path: &#39;*.Rcheck\\**\\*.log&#39; name: Logs - path: &#39;*.Rcheck\\**\\*.out&#39; name: Logs - path: &#39;*.Rcheck\\**\\*.fail&#39; name: Logs - path: &#39;*.Rcheck\\**\\*.Rout&#39; name: Logs - path: &#39;\\*_*.tar.gz&#39; name: Bits - path: &#39;\\*_*.zip&#39; name: Bits Here, we only run some tests and checks, since we already got the code analysis and coverage. Code coverage of our project yielded us the following results: Code coverage If we check the travis log, we see it has succeeded, because all tests ran through. However, we have some lints we should fix. $ tar -C .. -xf $PKG_TARBALL after_script.2 2.22s$ Rscript -e 'covr::codecov()' $message [1] \"Coverage reports upload successfully\" $id [1] \"552fd0db-187b-434e-b37b-a0e4fcba7636\" $meta $meta$status [1] 200 $queued [1] TRUE $url [1] \"https://codecov.io/github/dirmeier/essential-R/commit/f24d277296f78512524f26f3ca3b31d202e122a1\" $uploaded [1] TRUE after_script.3 1.23s$ Rscript -e 'lintr::lint_package()' R/bad_bad_file.R:3:1: style: lines should not be more than 80 characters. myRet = a+b ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ R/bad_bad_file.R:3:79: style: Variable and function names should be all lowercase. myRet = a+b ^~~~~ R/bad_bad_file.R:3:85: style: Use Fixing style related issues is essential since we want other people to be able to read our code easily. Good code also increases the number of users, because the package is more trusted than a spaghetti code package. Beauty is more important in computing than anywhere else in technology because software is so complicated. Beauty is the ultimate defense against complexity. – David Gelernter 3.2 Version control Aside from he fact that version control is great, putting your project on GitHub has the most prominent advantage that you can add badges to your README.md to show others about the state of your package, for instance repository, CI or code coverage status. There’s a wide variety of badges to describe your project. Description Badge Is the project passing on windows? How long is it on Bioconductor? Is it installable using conda? What is its version on CRAN? How often has it been downloaded? 3.3 Docker todo (needed for debugging c++) 3.4 Code style I try to follow two general guidelines when writing code. These are primarily not my personal preferences, nut adopted form packages like data.table, lme4, Matrix or Bioconductor. Whatever you do, just be consistent. There seem to be a lot of different preference around. If I mainly write using S3 classes and functions I prefer writing code like this: my.var &lt;- &quot;2&quot; i.am.a.function &lt;- function(i) { sapply(seq(10), function(i) { i + 1 }) } plot.me &lt;- function(x, ...) plot.default(x) .i.am.private &lt;- &quot;2&quot; For S4 classes and functions I recommend using the Bioconductor style guide or how lme4 and Matrix do it: setMethod(&quot;camelCaps&quot;, signature = signature(iAmAList = &quot;list&quot;)) "]
]
